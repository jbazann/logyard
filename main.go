package main

import (
	"bufio"
	"bytes"
	"context"
	_ "embed"
	"errors"
	"flag"
	"fmt"
	"io"
	"log"
	"math/rand"
	"net/http"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/gorilla/websocket"
	"gopkg.in/natefinch/lumberjack.v2"
)

//go:embed index.html
var indexHTML string

//go:embed viewer.html
var viewerHTML string

const (
	DEFAULT_PORT        int    = 23212
	READ_BUFFER_SIZE    int    = 2048
	LOG_FILE            string = "logyard"
	HOME_DIR_SYMBOL     string = "app://"
	DEFAULT_CAPTURE_DIR string = HOME_DIR_SYMBOL + "captures/"
)

const LOGGER_FLAGS int = log.Ldate | log.Ltime | log.Lmicroseconds | log.Lshortfile | log.Lmsgprefix

var (
	port       int    // Server port (server mode only).
	pollMs     int    // Polling rate when streaming files in polling mode (server mode only).
	demo       int    // Lines to print in demo mode (demo mode only).
	demoSpread int    // Max milliseconds to sleep in demo mode (demo mode only).
	chunkMB    int    // Max rolling log file size, in megabytes.
	runId      string // Capture ID (capture mode only).
	// Where process files are found/created. May or may not have a trailing slash.
	// This this the value 'app://' expands to for user-provided paths.
	homePath string
	// Where capture files are created (capture mode only).
	capturePath string
	sourcePaths string // The source path(s) as provided by the user (comma-separated list).
	capture     bool   // Whether the process should run in capture mode.
	logging     bool   // Whether the process should write its own logs.
	captureLogs bool   // Whether the process should write its own logs to a capture file.
	rolling     bool   // Whether log files should be cycled (capture mode only).
)

func parseArgs() {
	// general flags
	flag.StringVar(&runId, "id", "", "A unique identifier for the capture and log file. Randomly generated by default.")
	flag.StringVar(&homePath, "hdir", "", "The home directory for Logyard (aliased as \"app://\" in other user-provided paths). "+
		"If empty, the installation directory will be used.")
	flag.BoolVar(&logging, "enable-logging", false, "Enable Logyard's own logging.")
	flag.BoolVar(&logging, "l", false, "Alias for '--enable-logging'.")
	flag.BoolVar(&captureLogs, "capture-logging", false, "Toggle Logyard's own logging directly into a capture file.")
	flag.BoolVar(&captureLogs, "cl", false, "Alias for '--capture-logging'.")
	flag.BoolVar(&rolling, "roll-logging", false, "Toggle rolling logs. Also applies to captures. Does not enable logging by itself.")
	flag.BoolVar(&rolling, "rl", false, "Alias for --roll-logging.")
	flag.IntVar(&chunkMB, "chunkmb", 10, "Max rolling log file size, in megabytes.")
	// server mode
	flag.IntVar(&port, "port", DEFAULT_PORT, "The port for the web UI.")
	flag.IntVar(&port, "p", DEFAULT_PORT, "Alias for '--port'.")
	flag.IntVar(&pollMs, "polling", 2000, "Polling interval when using polling mode to stream a file'.")
	flag.StringVar(&sourcePaths, "src", DEFAULT_CAPTURE_DIR, "A comma-separated (,) list of paths to scan for log files. "+
		"May contain directories or specific files. Directories are always scanned recursively. Server mode only.")
	// capture mode
	flag.BoolVar(&capture, "capture", false, "Toggle capture mode.")
	flag.BoolVar(&capture, "c", false, "Alias for '--capture'.")
	flag.StringVar(&capturePath, "cdir", DEFAULT_CAPTURE_DIR, "The directory where capture files are created.")
	// demo mode
	flag.IntVar(&demo, "demo", -1, "A number of lines to print to sdout. Triggers demo mode. A value of zero (0) will print logs indefinitely.")
	flag.IntVar(&demoSpread, "demoSpread", 500, "The maximum number of milliseconds to sleep between demo logs. The actual time is randomized between prints, following a linear distribution.")
	flag.Parse()
}

type CoreResources struct {
	shutdown chan int
}

type ServerResources struct {
	cachedResponse atomic.Pointer[[]byte]
	s              *http.Server
	mux            *http.ServeMux
	log            *log.Logger
	allSources     []SourceDescriptor
	statSources    []SourceDescriptor
}

type SourceDescriptor struct {
	rawPath string
	path    string
	valid   bool
	info    os.FileInfo
	sub     *[]SourceDescriptor
}

func main() {
	initFlags()
	cr, err := initResources()
	if err != nil {
		log.Fatal(err)
	}
	if demo >= 0 {
		log.Printf("Starting demo mode. Iterations: %d. Sleep: %d", demo, demoSpread)
		runDemo(demo, cr)
		return
	}
	if capture {
		log.Printf("Starting capture mode. Capture id: \"%s\". Home path: \"%s\". Capture path: \"%s\"", runId, homePath, capturePath)
		err = startCapture(cr)
	} else {
		log.Println("Starting server mode.")
		err = startServer(cr)
	}
	if err != nil {
		log.Fatal(err)
	}
}

func initFlags() {
	parseArgs()
	if (capture || captureLogs) && runId == "" {
		secOfYear := (time.Now().UnixMilli() / 1000) % (60 * 60 * 24 * 365)
		runId = fmt.Sprintf("autonamed-%d", secOfYear)
	}
}

func initResources() (cr *CoreResources, err error) {
	cr = &CoreResources{}
	cr.shutdown = make(chan int)
	if logging || captureLogs {
		log.SetFlags(LOGGER_FLAGS)
		log.SetPrefix("[Main] ")
	} else {
		log.SetOutput(io.Discard)
	}

	if !captureLogs { // otherwise delay the log until opening the file
		// TODO logging buffer
		log.Printf("Initializing with args: %+v", os.Args)
	}

	if homePath == "" {
		ex, err := os.Executable()
		if err != nil {
			return cr, fmt.Errorf("failed to read home path: %+v", err)
		}
		homePath, err = resolveAbsolutePath(filepath.Dir(ex))
		if err != nil {
			return cr, fmt.Errorf("failed to resolve home path: %+v", err)
		}
		if !strings.HasSuffix(homePath, string(filepath.Separator)) {
			homePath += string(filepath.Separator)
		}
	}

	capturePath, err = resolveAbsolutePath(capturePath)
	if err != nil {
		return cr, fmt.Errorf("failed to resolve capture path: %+v", err)
	}
	if !strings.HasSuffix(capturePath, string(filepath.Separator)) {
		capturePath += string(filepath.Separator)
	}

	if capture || captureLogs {
		err = os.MkdirAll(filepath.Dir(capturePath), 0755)
		if err != nil {
			return cr, fmt.Errorf("failed to create capture directory: %+v", err)
		}
	}

	if captureLogs {
		path := filepath.Join(capturePath, fmt.Sprintf("%s-%s.log", runId, LOG_FILE))
		if rolling {
			log.SetOutput(*getRollingLogger(path))
		} else {
			lf, err := os.Create(path)
			if err != nil {
				err = fmt.Errorf("failed to create log file %q: %+v", path, err)
				return cr, err
			}
			log.SetOutput(lf)
			log.Printf("Initializing with args: %+v", flag.Args()) // TODO logging buffer
		}
	}

	log.Printf("Resources initialized. Working under %q", homePath)

	if capture || captureLogs {
		log.Printf("Capture path: %q", capturePath)
	}

	return cr, err
}

func getRollingLogger(filename string) *io.Writer {
	if !strings.HasSuffix(filename, ".log") {
		filename += ".log"
	}
	var w io.Writer = &lumberjack.Logger{
		Filename: filename,
		MaxSize:  chunkMB, // MB
	}
	return &w
}

func runDemo(lines int, cr *CoreResources) {
	const format = "Demo log line %d. Sample string: %q"
	const sample = "this string will appear %d times :)"
	if lines == 0 {
		i := uint64(0)
		for {
			time.Sleep(time.Duration(rand.Intn(demoSpread)) * time.Millisecond)
			n := slices.Min([]int{rand.Intn(12), rand.Intn(12), rand.Intn(12)}) + 1
			log.Printf(format, i, strings.Join(slices.Repeat([]string{fmt.Sprintf(sample, n)}, n), " "))
			i++
		}
	} else {
		for i := range lines {
			time.Sleep(time.Duration(rand.Intn(demoSpread)) * time.Millisecond)
			n := slices.Min([]int{rand.Intn(12), rand.Intn(12), rand.Intn(12)}) + 1
			log.Printf(format, i, strings.Join(slices.Repeat([]string{fmt.Sprintf(sample, n)}, n), " "))
		}
	}

}

func startCapture(cr *CoreResources) (err error) {
	var writer io.Writer
	if rolling {
		path := filepath.Join(capturePath, runId, runId)
		writer = *getRollingLogger(path)
	} else {
		path := filepath.Join(capturePath, runId+".log")
		log.Printf("Creating capture file: %q", path)
		f, err := os.Create(path)
		if err != nil {
			return fmt.Errorf("failed to create capture file: %+v", err)
		}
		writer = f
	}

	_, err = io.Copy(writer, os.Stdin)
	return err
}

func startServer(cr *CoreResources) (err error) {
	sr := ServerResources{}
	sr.log = getLogger("[Server]")
	sr.log.Printf("Resolving sourcePaths: %q", sourcePaths)
	var resolved []string
	for str := range strings.SplitSeq(sourcePaths, ",") {
		var sd SourceDescriptor
		sd.rawPath = str
		abs, err := resolveAbsolutePath(str)
		if sd.valid = err == nil; sd.valid {
			sd.path = abs
			resolved = append(resolved, abs)
		} else {
			log.Printf("failed to resolve source path %q: %+v", str, err)
		}
		sr.allSources = append(sr.allSources, sd)
	}
	sr.log.Printf("Resolved sources: %q", resolved)
	statSources(&sr)
	buildHome(&sr)

	addr := fmt.Sprintf(":%d", port)
	shutdown := buildServer(&sr, addr)

	sr.log.Printf("Starting server on: %q", addr)
	err = sr.s.ListenAndServe()
	if err != http.ErrServerClosed {
		return err
	}
	sr.log.Print("Server returned. Awaiting shutdown signal.")
	_, ok := <-shutdown
	if !ok {
		return errors.New("shutdown channel closed before receiving shutdown signal")
	}
	sr.log.Print("Shutdown signal received. Ending server mode.")
	return nil
}

func statSources(sr *ServerResources) {
	for _, src := range sr.allSources {
		if !src.valid {
			continue
		}
		i, err := os.Stat(src.path)
		if err != nil {
			sr.log.Printf("failed stat %q: %+v", src.path, err)
			continue
		}
		if !strings.HasSuffix(i.Name(), ".log") && !i.IsDir() {
			sr.log.Printf("Warning: not a log file or directory %q", src.path)
			continue
		}
		src.info = i
		if !src.info.IsDir() {
			continue
		}
		src.sub = new([]SourceDescriptor)
		sr.log.Printf("Walking %q", src.path)
		filepath.WalkDir(src.path, func(path string, d os.DirEntry, err error) error {
			if err != nil {
				sr.log.Printf("Found problematic path %q: %+v", path, err)
				sr.log.Printf("Aborting walk of %q", src.path)
				return err
			}
			if strings.HasSuffix(path, ".log") {
				f, err := os.Stat(path)
				if err != nil {
					sr.log.Print(err)
					return nil
				}
				sd := SourceDescriptor{
					rawPath: path,
					path:    path,
					valid:   true,
					info:    f,
				}
				*src.sub = append(*src.sub, sd)
				sr.log.Printf("Confirmed %q sub-source: %q", src.path, sd.path)
			}
			return nil
		})
		sr.statSources = append(sr.statSources, src)
		sr.log.Printf("Confirmed source: %q", src.path)
	}
}

func buildServer(sr *ServerResources, addr string) (shutdown chan any) {
	shutdown = make(chan any)
	sr.mux = http.DefaultServeMux
	sr.s = &http.Server{
		Addr:    addr,
		Handler: sr.mux,
	}

	sr.mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		sr.log.Print("[/]")
		w.Write(*sr.cachedResponse.Load())
	})
	sr.mux.HandleFunc("/$", func(w http.ResponseWriter, r *http.Request) {
		sr.log.Print("[/$]")
		http.Redirect(w, r, "/", http.StatusFound)
		go func() {
			sr.log.Print("Shutting down...")
			sr.s.Shutdown(context.Background())
			shutdown <- struct{}{}
		}()
	})

	for _, ss := range sr.statSources {
		if ss.info.IsDir() {
			for _, sub := range *ss.sub {
				if sub.info.IsDir() {
					continue
				}
				buildSourceEndpoints(sr, &sub)
			}
		} else {
			buildSourceEndpoints(sr, &ss)
		}
	}

	return shutdown
}

func buildSourceEndpoints(sr *ServerResources, src *SourceDescriptor) {
	path, _ := strings.CutPrefix(src.path, "/")
	path = "/src/" + strings.ReplaceAll(path, "\\", "/")
	document := []byte(strings.Replace(viewerHTML, "<!--PATH-->", src.path, 1))
	sr.log.Printf("Endpoint %s", path)
	sr.mux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {
		sr.log.Printf("[%s]", path)
		w.Write(document)
	})
	upgrader := websocket.Upgrader{
		ReadBufferSize:    0,
		WriteBufferSize:   2048,
		WriteBufferPool:   &sync.Pool{},
		EnableCompression: true,
	}
	wspath := path + "/$"
	sr.mux.HandleFunc(wspath, func(w http.ResponseWriter, r *http.Request) {
		tag := fmt.Sprintf("[%s]", wspath)
		sr.log.Print(tag)
		c, err := upgrader.Upgrade(w, r, nil)
		if err != nil {
			sr.log.Printf("%s Upgrade error: %+v", tag, err)
		}
		go logReads(tag, sr, c)
		streamLogFile(tag, sr, src, c)
	})
}

type WriterFunc func([]byte) (int, error)

func (f WriterFunc) Write(p []byte) (int, error) { return f(p) }

func streamLogFile(tag string, sr *ServerResources, sd *SourceDescriptor, conn *websocket.Conn) {
	f, err := os.Open(sd.path)
	if err != nil {
		sr.log.Printf("%s File error: %+v", tag, err)
		conn.Close()
		return
	}
	r := bufio.NewReaderSize(f, READ_BUFFER_SIZE)
	var partial []byte
	var eof bool
	t := time.NewTimer(0)
	var lastKnownSize int64
	for {
		info, err := os.Stat(sd.path)
		if err != nil {
			sr.log.Printf("%s Stat error: %+v", tag, err)
			conn.Close()
			return
		}
		if info.Size() > lastKnownSize {
			lastKnownSize = info.Size()
			eof = false
		}
		for !eof {
			line, err := r.ReadBytes('\n')
			if err == io.EOF {
				if len(line) != 0 {
					if partial != nil {
						partial = bytes.Join([][]byte{partial, line}, nil)
					} else {
						partial = line
					}
				}
				eof = true
				break
			}
			if err != nil {
				sr.log.Printf("%s Reader error: %+v", tag, err)
				last := bytes.Join([][]byte{partial, line}, nil)
				if len(last) != 0 {
					err = conn.WriteMessage(websocket.TextMessage, []byte(last))
					if err != nil {
						sr.log.Printf("%s Write error: %+v", tag, err)
					}
				}
				conn.Close()
				return
			}
			if partial != nil {
				line = bytes.Join([][]byte{partial, line}, nil)
				partial = nil
			}
			conn.WriteMessage(websocket.TextMessage, line)
		}
		t.Reset(time.Duration(pollMs))
		<-t.C
	}

}

func logReads(tag string, sr *ServerResources, conn *websocket.Conn) {
	for {
		if t, b, err := conn.ReadMessage(); err != nil {
			sr.log.Printf("%s Read error: %+v", tag, err)
			break
		} else {
			sr.log.Printf("%s Unexpected read (type %d): %q", tag, t, string(b))
		}
	}
}

const sourceGroupHTML string = "<li><h3>%s</h3><ul>%s</ul></li>"
const sourceLinkHTML string = "<li><a href=\"/src/%s\">%s</a></li>"

func buildHome(sr *ServerResources) {
	sr.log.Printf("Building home with %d root sources.", len(sr.statSources))
	var sb strings.Builder
	for _, ss := range sr.statSources {
		if ss.info.IsDir() {
			var group strings.Builder
			sr.log.Printf("Listing %d sources under %q.", len(*ss.sub), ss.path)
			for _, sub := range *ss.sub {
				if sub.info.IsDir() {
					continue
				}
				rel, err := filepath.Rel(ss.path, sub.path)
				if err != nil {
					sr.log.Printf("Relative sub-source path error: %+v", err)
					continue
				}
				group.Write(fmt.Appendf(nil, sourceLinkHTML, sub.path, rel))
			}
			sb.Write(fmt.Appendf(nil, sourceGroupHTML, ss.path, group.String()))
		} else {
			sb.Write(fmt.Appendf(nil, sourceLinkHTML, ss.path, ss.path))
		}
	}
	resp := []byte(strings.Replace(indexHTML, "<!--SOURCES-->", sb.String(), 1))
	sr.cachedResponse.Store(&resp)
}

func getLogger(p string) *log.Logger {
	var l log.Logger
	l.SetFlags(LOGGER_FLAGS)
	l.SetOutput(log.Writer())
	if strings.HasSuffix(p, " ") {
		l.SetPrefix(p)
	} else if p != "" {
		l.SetPrefix(p + " ")
	}
	return &l
}

func resolveAbsolutePath(p string) (_ string, err error) {
	if fromHome, found := strings.CutPrefix(p, "app://"); found {
		p = filepath.Join(homePath, fromHome)
	}
	if !filepath.IsAbs(p) {
		p, err = filepath.Abs(p)
		if err != nil {
			return p, err
		}
	}
	return p, nil
}

func resolveRelativePath(p string) (_ string, err error) {
	if fromHome, found := strings.CutPrefix(p, "app://"); found {
		p = filepath.Join(homePath, fromHome)
	} else if filepath.IsAbs(p) {
		return filepath.Rel(homePath, p)
	}
	return p, nil
}
